"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const vitest_1 = require("vitest");
const keystroke_fist_1 = require("./keystroke-fist");
const buildSession = (typingStream) => ({
    sessionId: 'session-test',
    agentId: 'voice-agent',
    typingStream: typingStream.map((delta, index) => ({
        deltaMs: delta,
        pressure: 0.6 + (index % 3) * 0.1,
        key: String.fromCharCode(65 + (index % 26)),
    })),
});
(0, vitest_1.describe)('Digital Fist Keystroke Oracle', () => {
    (0, vitest_1.it)('rejects anonymous invaders when score below threshold', async () => {
        const proof = await keystroke_fist_1.KeystrokeOracle.verify(buildSession([]));
        (0, vitest_1.expect)(proof.status).toBe('REJECTED');
        (0, vitest_1.expect)(proof.reason).toBe('ANONYMOUS_INVADER');
        (0, vitest_1.expect)(proof.score).toBeLessThan(keystroke_fist_1.MIN_FIST_SCORE);
    });
    (0, vitest_1.it)('validates sessions when guard score exceeds threshold', async () => {
        const spy = vitest_1.vi.spyOn(keystroke_fist_1.fistGuard, 'evaluate').mockResolvedValue(keystroke_fist_1.MIN_FIST_SCORE + 0.02);
        const proof = await keystroke_fist_1.KeystrokeOracle.verify(buildSession([100, 100, 98, 102]));
        (0, vitest_1.expect)(proof.status).toBe('VALID');
        (0, vitest_1.expect)(proof.score).toBeGreaterThanOrEqual(keystroke_fist_1.MIN_FIST_SCORE);
        spy.mockRestore();
    });
    (0, vitest_1.it)('produces deterministic scores for the same stream', async () => {
        const session = buildSession([100, 120, 100, 120, 110, 105, 98, 115]);
        const first = await keystroke_fist_1.fistGuard.evaluate(session.typingStream);
        const second = await keystroke_fist_1.fistGuard.evaluate(session.typingStream);
        (0, vitest_1.expect)(first).toBe(second);
    });
});
//# sourceMappingURL=keystroke-fist.test.js.map