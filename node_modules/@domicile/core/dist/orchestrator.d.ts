import { z } from "zod";
export declare const EnhancementAreaZod: z.ZodObject<{
    name: z.ZodString;
    objective: z.ZodString;
    key_requirements: z.ZodArray<z.ZodString, "many">;
    sources: z.ZodArray<z.ZodString, "many">;
    depends_on: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    name: string;
    objective: string;
    key_requirements: string[];
    sources: string[];
    depends_on?: string[] | undefined;
}, {
    name: string;
    objective: string;
    key_requirements: string[];
    sources: string[];
    depends_on?: string[] | undefined;
}>;
export type EnhancementArea = z.infer<typeof EnhancementAreaZod>;
export declare const QuantumComputeFormatZod: z.ZodObject<{
    type: z.ZodEnum<["QUBO", "Oracle", "QFT-Arithmetic"]>;
    parameters: z.ZodRecord<z.ZodString, z.ZodAny>;
    constraints: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    type: "QUBO" | "Oracle" | "QFT-Arithmetic";
    parameters: Record<string, any>;
    constraints?: string[] | undefined;
}, {
    type: "QUBO" | "Oracle" | "QFT-Arithmetic";
    parameters: Record<string, any>;
    constraints?: string[] | undefined;
}>;
export type QuantumComputeFormat = z.infer<typeof QuantumComputeFormatZod>;
export declare const HardwareRecommendationZod: z.ZodObject<{
    weights: z.ZodObject<{
        fidelity: z.ZodNumber;
        speed: z.ZodNumber;
        cost: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        fidelity: number;
        speed: number;
        cost: number;
    }, {
        fidelity: number;
        speed: number;
        cost: number;
    }>;
    feasibility_threshold: z.ZodNumber;
    preferred_backend: z.ZodOptional<z.ZodEnum<["trapped-ion", "superconducting", "photonic", "hybrid"]>>;
}, "strip", z.ZodTypeAny, {
    weights: {
        fidelity: number;
        speed: number;
        cost: number;
    };
    feasibility_threshold: number;
    preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
}, {
    weights: {
        fidelity: number;
        speed: number;
        cost: number;
    };
    feasibility_threshold: number;
    preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
}>;
export type HardwareRecommendation = z.infer<typeof HardwareRecommendationZod>;
export declare const TTSDelegationZod: z.ZodObject<{
    segments: z.ZodArray<z.ZodObject<{
        text: z.ZodString;
        requires_expressive_synthesis: z.ZodBoolean;
        voice_model: z.ZodOptional<z.ZodString>;
        emotion: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        text: string;
        requires_expressive_synthesis: boolean;
        voice_model?: string | undefined;
        emotion?: string | undefined;
    }, {
        text: string;
        requires_expressive_synthesis: boolean;
        voice_model?: string | undefined;
        emotion?: string | undefined;
    }>, "many">;
    synthesis_engine: z.ZodEnum<["ECHO-GHOST", "ADAPT-Voice", "standard"]>;
    quality_target: z.ZodEnum<["high-fidelity", "real-time", "balanced"]>;
}, "strip", z.ZodTypeAny, {
    segments: {
        text: string;
        requires_expressive_synthesis: boolean;
        voice_model?: string | undefined;
        emotion?: string | undefined;
    }[];
    synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
    quality_target: "high-fidelity" | "real-time" | "balanced";
}, {
    segments: {
        text: string;
        requires_expressive_synthesis: boolean;
        voice_model?: string | undefined;
        emotion?: string | undefined;
    }[];
    synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
    quality_target: "high-fidelity" | "real-time" | "balanced";
}>;
export type TTSDelegation = z.infer<typeof TTSDelegationZod>;
export declare const GovernanceZod: z.ZodObject<{
    security: z.ZodString;
    compliance: z.ZodString;
    ethics: z.ZodString;
    data_handling: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    security: string;
    compliance: string;
    ethics: string;
    data_handling?: string | undefined;
}, {
    security: string;
    compliance: string;
    ethics: string;
    data_handling?: string | undefined;
}>;
export type GovernanceConfig = z.infer<typeof GovernanceZod>;
export declare const ExecutionFabricZod: z.ZodObject<{
    biometric_attestation: z.ZodDefault<z.ZodLiteral<"fist">>;
    oracle_id: z.ZodString;
    min_score: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    biometric_attestation: "fist";
    oracle_id: string;
    min_score: number;
}, {
    oracle_id: string;
    min_score: number;
    biometric_attestation?: "fist" | undefined;
}>;
export type ExecutionFabric = z.infer<typeof ExecutionFabricZod>;
export declare const ImplementationPlanZod: z.ZodObject<{
    modules: z.ZodArray<z.ZodString, "many">;
    architecture: z.ZodString;
    estimated_effort: z.ZodOptional<z.ZodString>;
    dependencies: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    modules: string[];
    architecture: string;
    estimated_effort?: string | undefined;
    dependencies?: string[] | undefined;
}, {
    modules: string[];
    architecture: string;
    estimated_effort?: string | undefined;
    dependencies?: string[] | undefined;
}>;
export type ImplementationPlan = z.infer<typeof ImplementationPlanZod>;
export declare const AgentOutputZod: z.ZodObject<{
    enhancement_area: z.ZodString;
    objective: z.ZodString;
    implementation_plan: z.ZodObject<{
        modules: z.ZodArray<z.ZodString, "many">;
        architecture: z.ZodString;
        estimated_effort: z.ZodOptional<z.ZodString>;
        dependencies: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        modules: string[];
        architecture: string;
        estimated_effort?: string | undefined;
        dependencies?: string[] | undefined;
    }, {
        modules: string[];
        architecture: string;
        estimated_effort?: string | undefined;
        dependencies?: string[] | undefined;
    }>;
    depends_on: z.ZodArray<z.ZodString, "many">;
    sources: z.ZodArray<z.ZodString, "many">;
    governance: z.ZodObject<{
        security: z.ZodString;
        compliance: z.ZodString;
        ethics: z.ZodString;
        data_handling: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        security: string;
        compliance: string;
        ethics: string;
        data_handling?: string | undefined;
    }, {
        security: string;
        compliance: string;
        ethics: string;
        data_handling?: string | undefined;
    }>;
    validation_criteria: z.ZodString;
    confidence_score: z.ZodNumber;
    estimated_completion_time: z.ZodOptional<z.ZodString>;
    execution_fabric: z.ZodOptional<z.ZodObject<{
        biometric_attestation: z.ZodDefault<z.ZodLiteral<"fist">>;
        oracle_id: z.ZodString;
        min_score: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        biometric_attestation: "fist";
        oracle_id: string;
        min_score: number;
    }, {
        oracle_id: string;
        min_score: number;
        biometric_attestation?: "fist" | undefined;
    }>>;
    quantum_compute_format: z.ZodOptional<z.ZodObject<{
        type: z.ZodEnum<["QUBO", "Oracle", "QFT-Arithmetic"]>;
        parameters: z.ZodRecord<z.ZodString, z.ZodAny>;
        constraints: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        type: "QUBO" | "Oracle" | "QFT-Arithmetic";
        parameters: Record<string, any>;
        constraints?: string[] | undefined;
    }, {
        type: "QUBO" | "Oracle" | "QFT-Arithmetic";
        parameters: Record<string, any>;
        constraints?: string[] | undefined;
    }>>;
    hardware_recommendation: z.ZodOptional<z.ZodObject<{
        weights: z.ZodObject<{
            fidelity: z.ZodNumber;
            speed: z.ZodNumber;
            cost: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            fidelity: number;
            speed: number;
            cost: number;
        }, {
            fidelity: number;
            speed: number;
            cost: number;
        }>;
        feasibility_threshold: z.ZodNumber;
        preferred_backend: z.ZodOptional<z.ZodEnum<["trapped-ion", "superconducting", "photonic", "hybrid"]>>;
    }, "strip", z.ZodTypeAny, {
        weights: {
            fidelity: number;
            speed: number;
            cost: number;
        };
        feasibility_threshold: number;
        preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
    }, {
        weights: {
            fidelity: number;
            speed: number;
            cost: number;
        };
        feasibility_threshold: number;
        preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
    }>>;
    tts_delegation: z.ZodOptional<z.ZodObject<{
        segments: z.ZodArray<z.ZodObject<{
            text: z.ZodString;
            requires_expressive_synthesis: z.ZodBoolean;
            voice_model: z.ZodOptional<z.ZodString>;
            emotion: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            text: string;
            requires_expressive_synthesis: boolean;
            voice_model?: string | undefined;
            emotion?: string | undefined;
        }, {
            text: string;
            requires_expressive_synthesis: boolean;
            voice_model?: string | undefined;
            emotion?: string | undefined;
        }>, "many">;
        synthesis_engine: z.ZodEnum<["ECHO-GHOST", "ADAPT-Voice", "standard"]>;
        quality_target: z.ZodEnum<["high-fidelity", "real-time", "balanced"]>;
    }, "strip", z.ZodTypeAny, {
        segments: {
            text: string;
            requires_expressive_synthesis: boolean;
            voice_model?: string | undefined;
            emotion?: string | undefined;
        }[];
        synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
        quality_target: "high-fidelity" | "real-time" | "balanced";
    }, {
        segments: {
            text: string;
            requires_expressive_synthesis: boolean;
            voice_model?: string | undefined;
            emotion?: string | undefined;
        }[];
        synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
        quality_target: "high-fidelity" | "real-time" | "balanced";
    }>>;
}, "strip", z.ZodTypeAny, {
    objective: string;
    sources: string[];
    depends_on: string[];
    enhancement_area: string;
    implementation_plan: {
        modules: string[];
        architecture: string;
        estimated_effort?: string | undefined;
        dependencies?: string[] | undefined;
    };
    governance: {
        security: string;
        compliance: string;
        ethics: string;
        data_handling?: string | undefined;
    };
    validation_criteria: string;
    confidence_score: number;
    estimated_completion_time?: string | undefined;
    execution_fabric?: {
        biometric_attestation: "fist";
        oracle_id: string;
        min_score: number;
    } | undefined;
    quantum_compute_format?: {
        type: "QUBO" | "Oracle" | "QFT-Arithmetic";
        parameters: Record<string, any>;
        constraints?: string[] | undefined;
    } | undefined;
    hardware_recommendation?: {
        weights: {
            fidelity: number;
            speed: number;
            cost: number;
        };
        feasibility_threshold: number;
        preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
    } | undefined;
    tts_delegation?: {
        segments: {
            text: string;
            requires_expressive_synthesis: boolean;
            voice_model?: string | undefined;
            emotion?: string | undefined;
        }[];
        synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
        quality_target: "high-fidelity" | "real-time" | "balanced";
    } | undefined;
}, {
    objective: string;
    sources: string[];
    depends_on: string[];
    enhancement_area: string;
    implementation_plan: {
        modules: string[];
        architecture: string;
        estimated_effort?: string | undefined;
        dependencies?: string[] | undefined;
    };
    governance: {
        security: string;
        compliance: string;
        ethics: string;
        data_handling?: string | undefined;
    };
    validation_criteria: string;
    confidence_score: number;
    estimated_completion_time?: string | undefined;
    execution_fabric?: {
        oracle_id: string;
        min_score: number;
        biometric_attestation?: "fist" | undefined;
    } | undefined;
    quantum_compute_format?: {
        type: "QUBO" | "Oracle" | "QFT-Arithmetic";
        parameters: Record<string, any>;
        constraints?: string[] | undefined;
    } | undefined;
    hardware_recommendation?: {
        weights: {
            fidelity: number;
            speed: number;
            cost: number;
        };
        feasibility_threshold: number;
        preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
    } | undefined;
    tts_delegation?: {
        segments: {
            text: string;
            requires_expressive_synthesis: boolean;
            voice_model?: string | undefined;
            emotion?: string | undefined;
        }[];
        synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
        quality_target: "high-fidelity" | "real-time" | "balanced";
    } | undefined;
}>;
export type AgentOutput = z.infer<typeof AgentOutputZod>;
export declare const ManifestMetadataZod: z.ZodObject<{
    version: z.ZodString;
    created_at: z.ZodString;
    last_modified: z.ZodString;
    commit_hash: z.ZodString;
    author: z.ZodString;
    environment: z.ZodEnum<["development", "staging", "production"]>;
    total_enhancements: z.ZodNumber;
    build_order: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    version: string;
    created_at: string;
    last_modified: string;
    commit_hash: string;
    author: string;
    environment: "development" | "staging" | "production";
    total_enhancements: number;
    build_order: string[];
}, {
    version: string;
    created_at: string;
    last_modified: string;
    commit_hash: string;
    author: string;
    environment: "development" | "staging" | "production";
    total_enhancements: number;
    build_order: string[];
}>;
export type ManifestMetadata = z.infer<typeof ManifestMetadataZod>;
export declare const OrchestratorManifestZod: z.ZodObject<{
    metadata: z.ZodObject<{
        version: z.ZodString;
        created_at: z.ZodString;
        last_modified: z.ZodString;
        commit_hash: z.ZodString;
        author: z.ZodString;
        environment: z.ZodEnum<["development", "staging", "production"]>;
        total_enhancements: z.ZodNumber;
        build_order: z.ZodArray<z.ZodString, "many">;
    }, "strip", z.ZodTypeAny, {
        version: string;
        created_at: string;
        last_modified: string;
        commit_hash: string;
        author: string;
        environment: "development" | "staging" | "production";
        total_enhancements: number;
        build_order: string[];
    }, {
        version: string;
        created_at: string;
        last_modified: string;
        commit_hash: string;
        author: string;
        environment: "development" | "staging" | "production";
        total_enhancements: number;
        build_order: string[];
    }>;
    enhancements: z.ZodArray<z.ZodObject<{
        enhancement_area: z.ZodString;
        objective: z.ZodString;
        implementation_plan: z.ZodObject<{
            modules: z.ZodArray<z.ZodString, "many">;
            architecture: z.ZodString;
            estimated_effort: z.ZodOptional<z.ZodString>;
            dependencies: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        }, "strip", z.ZodTypeAny, {
            modules: string[];
            architecture: string;
            estimated_effort?: string | undefined;
            dependencies?: string[] | undefined;
        }, {
            modules: string[];
            architecture: string;
            estimated_effort?: string | undefined;
            dependencies?: string[] | undefined;
        }>;
        depends_on: z.ZodArray<z.ZodString, "many">;
        sources: z.ZodArray<z.ZodString, "many">;
        governance: z.ZodObject<{
            security: z.ZodString;
            compliance: z.ZodString;
            ethics: z.ZodString;
            data_handling: z.ZodOptional<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            security: string;
            compliance: string;
            ethics: string;
            data_handling?: string | undefined;
        }, {
            security: string;
            compliance: string;
            ethics: string;
            data_handling?: string | undefined;
        }>;
        validation_criteria: z.ZodString;
        confidence_score: z.ZodNumber;
        estimated_completion_time: z.ZodOptional<z.ZodString>;
        execution_fabric: z.ZodOptional<z.ZodObject<{
            biometric_attestation: z.ZodDefault<z.ZodLiteral<"fist">>;
            oracle_id: z.ZodString;
            min_score: z.ZodNumber;
        }, "strip", z.ZodTypeAny, {
            biometric_attestation: "fist";
            oracle_id: string;
            min_score: number;
        }, {
            oracle_id: string;
            min_score: number;
            biometric_attestation?: "fist" | undefined;
        }>>;
        quantum_compute_format: z.ZodOptional<z.ZodObject<{
            type: z.ZodEnum<["QUBO", "Oracle", "QFT-Arithmetic"]>;
            parameters: z.ZodRecord<z.ZodString, z.ZodAny>;
            constraints: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        }, "strip", z.ZodTypeAny, {
            type: "QUBO" | "Oracle" | "QFT-Arithmetic";
            parameters: Record<string, any>;
            constraints?: string[] | undefined;
        }, {
            type: "QUBO" | "Oracle" | "QFT-Arithmetic";
            parameters: Record<string, any>;
            constraints?: string[] | undefined;
        }>>;
        hardware_recommendation: z.ZodOptional<z.ZodObject<{
            weights: z.ZodObject<{
                fidelity: z.ZodNumber;
                speed: z.ZodNumber;
                cost: z.ZodNumber;
            }, "strip", z.ZodTypeAny, {
                fidelity: number;
                speed: number;
                cost: number;
            }, {
                fidelity: number;
                speed: number;
                cost: number;
            }>;
            feasibility_threshold: z.ZodNumber;
            preferred_backend: z.ZodOptional<z.ZodEnum<["trapped-ion", "superconducting", "photonic", "hybrid"]>>;
        }, "strip", z.ZodTypeAny, {
            weights: {
                fidelity: number;
                speed: number;
                cost: number;
            };
            feasibility_threshold: number;
            preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
        }, {
            weights: {
                fidelity: number;
                speed: number;
                cost: number;
            };
            feasibility_threshold: number;
            preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
        }>>;
        tts_delegation: z.ZodOptional<z.ZodObject<{
            segments: z.ZodArray<z.ZodObject<{
                text: z.ZodString;
                requires_expressive_synthesis: z.ZodBoolean;
                voice_model: z.ZodOptional<z.ZodString>;
                emotion: z.ZodOptional<z.ZodString>;
            }, "strip", z.ZodTypeAny, {
                text: string;
                requires_expressive_synthesis: boolean;
                voice_model?: string | undefined;
                emotion?: string | undefined;
            }, {
                text: string;
                requires_expressive_synthesis: boolean;
                voice_model?: string | undefined;
                emotion?: string | undefined;
            }>, "many">;
            synthesis_engine: z.ZodEnum<["ECHO-GHOST", "ADAPT-Voice", "standard"]>;
            quality_target: z.ZodEnum<["high-fidelity", "real-time", "balanced"]>;
        }, "strip", z.ZodTypeAny, {
            segments: {
                text: string;
                requires_expressive_synthesis: boolean;
                voice_model?: string | undefined;
                emotion?: string | undefined;
            }[];
            synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
            quality_target: "high-fidelity" | "real-time" | "balanced";
        }, {
            segments: {
                text: string;
                requires_expressive_synthesis: boolean;
                voice_model?: string | undefined;
                emotion?: string | undefined;
            }[];
            synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
            quality_target: "high-fidelity" | "real-time" | "balanced";
        }>>;
    }, "strip", z.ZodTypeAny, {
        objective: string;
        sources: string[];
        depends_on: string[];
        enhancement_area: string;
        implementation_plan: {
            modules: string[];
            architecture: string;
            estimated_effort?: string | undefined;
            dependencies?: string[] | undefined;
        };
        governance: {
            security: string;
            compliance: string;
            ethics: string;
            data_handling?: string | undefined;
        };
        validation_criteria: string;
        confidence_score: number;
        estimated_completion_time?: string | undefined;
        execution_fabric?: {
            biometric_attestation: "fist";
            oracle_id: string;
            min_score: number;
        } | undefined;
        quantum_compute_format?: {
            type: "QUBO" | "Oracle" | "QFT-Arithmetic";
            parameters: Record<string, any>;
            constraints?: string[] | undefined;
        } | undefined;
        hardware_recommendation?: {
            weights: {
                fidelity: number;
                speed: number;
                cost: number;
            };
            feasibility_threshold: number;
            preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
        } | undefined;
        tts_delegation?: {
            segments: {
                text: string;
                requires_expressive_synthesis: boolean;
                voice_model?: string | undefined;
                emotion?: string | undefined;
            }[];
            synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
            quality_target: "high-fidelity" | "real-time" | "balanced";
        } | undefined;
    }, {
        objective: string;
        sources: string[];
        depends_on: string[];
        enhancement_area: string;
        implementation_plan: {
            modules: string[];
            architecture: string;
            estimated_effort?: string | undefined;
            dependencies?: string[] | undefined;
        };
        governance: {
            security: string;
            compliance: string;
            ethics: string;
            data_handling?: string | undefined;
        };
        validation_criteria: string;
        confidence_score: number;
        estimated_completion_time?: string | undefined;
        execution_fabric?: {
            oracle_id: string;
            min_score: number;
            biometric_attestation?: "fist" | undefined;
        } | undefined;
        quantum_compute_format?: {
            type: "QUBO" | "Oracle" | "QFT-Arithmetic";
            parameters: Record<string, any>;
            constraints?: string[] | undefined;
        } | undefined;
        hardware_recommendation?: {
            weights: {
                fidelity: number;
                speed: number;
                cost: number;
            };
            feasibility_threshold: number;
            preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
        } | undefined;
        tts_delegation?: {
            segments: {
                text: string;
                requires_expressive_synthesis: boolean;
                voice_model?: string | undefined;
                emotion?: string | undefined;
            }[];
            synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
            quality_target: "high-fidelity" | "real-time" | "balanced";
        } | undefined;
    }>, "many">;
    roadmap: z.ZodObject<{
        nodes: z.ZodArray<z.ZodString, "many">;
        edges: z.ZodArray<z.ZodObject<{
            from: z.ZodString;
            to: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            to: string;
            from: string;
        }, {
            to: string;
            from: string;
        }>, "many">;
        build_order: z.ZodArray<z.ZodString, "many">;
    }, "strip", z.ZodTypeAny, {
        build_order: string[];
        nodes: string[];
        edges: {
            to: string;
            from: string;
        }[];
    }, {
        build_order: string[];
        nodes: string[];
        edges: {
            to: string;
            from: string;
        }[];
    }>;
}, "strip", z.ZodTypeAny, {
    metadata: {
        version: string;
        created_at: string;
        last_modified: string;
        commit_hash: string;
        author: string;
        environment: "development" | "staging" | "production";
        total_enhancements: number;
        build_order: string[];
    };
    enhancements: {
        objective: string;
        sources: string[];
        depends_on: string[];
        enhancement_area: string;
        implementation_plan: {
            modules: string[];
            architecture: string;
            estimated_effort?: string | undefined;
            dependencies?: string[] | undefined;
        };
        governance: {
            security: string;
            compliance: string;
            ethics: string;
            data_handling?: string | undefined;
        };
        validation_criteria: string;
        confidence_score: number;
        estimated_completion_time?: string | undefined;
        execution_fabric?: {
            biometric_attestation: "fist";
            oracle_id: string;
            min_score: number;
        } | undefined;
        quantum_compute_format?: {
            type: "QUBO" | "Oracle" | "QFT-Arithmetic";
            parameters: Record<string, any>;
            constraints?: string[] | undefined;
        } | undefined;
        hardware_recommendation?: {
            weights: {
                fidelity: number;
                speed: number;
                cost: number;
            };
            feasibility_threshold: number;
            preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
        } | undefined;
        tts_delegation?: {
            segments: {
                text: string;
                requires_expressive_synthesis: boolean;
                voice_model?: string | undefined;
                emotion?: string | undefined;
            }[];
            synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
            quality_target: "high-fidelity" | "real-time" | "balanced";
        } | undefined;
    }[];
    roadmap: {
        build_order: string[];
        nodes: string[];
        edges: {
            to: string;
            from: string;
        }[];
    };
}, {
    metadata: {
        version: string;
        created_at: string;
        last_modified: string;
        commit_hash: string;
        author: string;
        environment: "development" | "staging" | "production";
        total_enhancements: number;
        build_order: string[];
    };
    enhancements: {
        objective: string;
        sources: string[];
        depends_on: string[];
        enhancement_area: string;
        implementation_plan: {
            modules: string[];
            architecture: string;
            estimated_effort?: string | undefined;
            dependencies?: string[] | undefined;
        };
        governance: {
            security: string;
            compliance: string;
            ethics: string;
            data_handling?: string | undefined;
        };
        validation_criteria: string;
        confidence_score: number;
        estimated_completion_time?: string | undefined;
        execution_fabric?: {
            oracle_id: string;
            min_score: number;
            biometric_attestation?: "fist" | undefined;
        } | undefined;
        quantum_compute_format?: {
            type: "QUBO" | "Oracle" | "QFT-Arithmetic";
            parameters: Record<string, any>;
            constraints?: string[] | undefined;
        } | undefined;
        hardware_recommendation?: {
            weights: {
                fidelity: number;
                speed: number;
                cost: number;
            };
            feasibility_threshold: number;
            preferred_backend?: "trapped-ion" | "superconducting" | "photonic" | "hybrid" | undefined;
        } | undefined;
        tts_delegation?: {
            segments: {
                text: string;
                requires_expressive_synthesis: boolean;
                voice_model?: string | undefined;
                emotion?: string | undefined;
            }[];
            synthesis_engine: "ECHO-GHOST" | "ADAPT-Voice" | "standard";
            quality_target: "high-fidelity" | "real-time" | "balanced";
        } | undefined;
    }[];
    roadmap: {
        build_order: string[];
        nodes: string[];
        edges: {
            to: string;
            from: string;
        }[];
    };
}>;
export type OrchestratorManifest = z.infer<typeof OrchestratorManifestZod>;
export declare class OrchestratorError extends Error {
    readonly timestamp: string;
    readonly correlationId: string;
    readonly errorType: string;
    readonly recoveryActions: string[];
    readonly context?: Record<string, any>;
    constructor(message: string, errorType?: string, recoveryActions?: string[], context?: Record<string, any>);
    toJSON(): {
        name: string;
        message: string;
        errorType: string;
        timestamp: string;
        correlationId: string;
        recoveryActions: string[];
        context: Record<string, any> | undefined;
        stack: string | undefined;
    };
}
export declare const TREND_DETECTION_EXAMPLE: AgentOutput;
export declare const QUANTUM_OPTIMIZATION_EXAMPLE: AgentOutput;
export declare const VOICE_SYNTHESIS_EXAMPLE: AgentOutput;
export declare const DEFAULT_QUBO_EXAMPLE: {
    type: "QUBO";
    parameters: {
        variables: number;
        linear_terms: number[];
        quadratic_terms: {
            "0,1": number;
            "1,2": number;
            "2,3": number;
            "3,4": number;
            "4,5": number;
            "5,6": number;
            "6,7": number;
            "7,8": number;
            "8,9": number;
            "9,10": number;
        };
        constraints: string[];
        objective_function: string;
    };
};
export declare const DEFAULT_GROVER_ORACLE_EXAMPLE: {
    type: "Oracle";
    parameters: {
        database_size: number;
        target_items: string[];
        marked_elements: number;
        oracle_function: string;
        success_probability: number;
    };
};
export declare const SecurityConfigZod: z.ZodObject<{
    rate_limiting: z.ZodObject<{
        requests_per_minute: z.ZodNumber;
        burst_limit: z.ZodNumber;
        enabled: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        requests_per_minute: number;
        burst_limit: number;
        enabled: boolean;
    }, {
        requests_per_minute: number;
        burst_limit: number;
        enabled: boolean;
    }>;
    api_key_vault: z.ZodObject<{
        provider: z.ZodEnum<["AWS Secrets Manager", "Azure Key Vault", "HashiCorp Vault"]>;
        key_rotation_days: z.ZodNumber;
        encryption_at_rest: z.ZodBoolean;
    }, "strip", z.ZodTypeAny, {
        provider: "AWS Secrets Manager" | "Azure Key Vault" | "HashiCorp Vault";
        key_rotation_days: number;
        encryption_at_rest: boolean;
    }, {
        provider: "AWS Secrets Manager" | "Azure Key Vault" | "HashiCorp Vault";
        key_rotation_days: number;
        encryption_at_rest: boolean;
    }>;
    prompt_injection_protection: z.ZodObject<{
        enabled: z.ZodBoolean;
        patterns: z.ZodArray<z.ZodString, "many">;
        sanitization_level: z.ZodEnum<["strict", "moderate", "permissive"]>;
    }, "strip", z.ZodTypeAny, {
        enabled: boolean;
        patterns: string[];
        sanitization_level: "strict" | "moderate" | "permissive";
    }, {
        enabled: boolean;
        patterns: string[];
        sanitization_level: "strict" | "moderate" | "permissive";
    }>;
}, "strip", z.ZodTypeAny, {
    rate_limiting: {
        requests_per_minute: number;
        burst_limit: number;
        enabled: boolean;
    };
    api_key_vault: {
        provider: "AWS Secrets Manager" | "Azure Key Vault" | "HashiCorp Vault";
        key_rotation_days: number;
        encryption_at_rest: boolean;
    };
    prompt_injection_protection: {
        enabled: boolean;
        patterns: string[];
        sanitization_level: "strict" | "moderate" | "permissive";
    };
}, {
    rate_limiting: {
        requests_per_minute: number;
        burst_limit: number;
        enabled: boolean;
    };
    api_key_vault: {
        provider: "AWS Secrets Manager" | "Azure Key Vault" | "HashiCorp Vault";
        key_rotation_days: number;
        encryption_at_rest: boolean;
    };
    prompt_injection_protection: {
        enabled: boolean;
        patterns: string[];
        sanitization_level: "strict" | "moderate" | "permissive";
    };
}>;
export type SecurityConfig = z.infer<typeof SecurityConfigZod>;
export declare const DEFAULT_SECURITY_CONFIG: SecurityConfig;
export declare class Orchestrator {
    private securityConfig;
    private pineconeInitialized;
    constructor(securityConfig?: SecurityConfig);
    compileManifest(enhancementAreas: EnhancementArea[], options?: {
        validateAgainstPinecone?: boolean;
        enableParallelProcessing?: boolean;
        environment?: 'development' | 'staging' | 'production';
    }): Promise<OrchestratorManifest>;
    validateAgentOutputs(outputs: unknown[]): Promise<{
        valid: AgentOutput[];
        invalid: Array<{
            output: unknown;
            errors: string[];
        }>;
    }>;
    executeDelegation(agentOutput: AgentOutput, context?: {
        quantumBackend?: string;
        voiceEngine?: string;
        securityContext?: unknown;
    }): Promise<{
        enhancement_area: string;
        execution_id: string;
        timestamp: string;
        results: Record<string, unknown>;
    }>;
    private generateAgentContract;
    private generateContractsSequential;
    private enrichManifestWithMetadata;
    private executeQuantumDelegation;
    private executeTTSDelegation;
    private executeImplementationPlan;
    initializeServices(): Promise<void>;
    getSecurityConfig(): SecurityConfig;
    isPineconeInitialized(): boolean;
}
export declare const orchestrator: Orchestrator;
//# sourceMappingURL=orchestrator.d.ts.map