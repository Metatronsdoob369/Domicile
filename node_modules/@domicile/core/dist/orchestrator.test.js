"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// src/orchestration/orchestrator.test.ts
const vitest_1 = require("vitest");
const orchestrator_1 = require("./orchestrator");
(0, vitest_1.describe)('Orchestrator Core', () => {
    (0, vitest_1.beforeEach)(async () => {
        // Reset orchestrator state for each test
        await orchestrator_1.orchestrator.initializeServices();
    });
    (0, vitest_1.describe)('Schema Validation', () => {
        (0, vitest_1.it)('should validate trend detection example', () => {
            const result = orchestrator_1.AgentOutputZod.safeParse(orchestrator_1.TREND_DETECTION_EXAMPLE);
            (0, vitest_1.expect)(result.success).toBe(true);
        });
        (0, vitest_1.it)('should validate quantum optimization example', () => {
            const result = orchestrator_1.AgentOutputZod.safeParse(orchestrator_1.QUANTUM_OPTIMIZATION_EXAMPLE);
            (0, vitest_1.expect)(result.success).toBe(true);
        });
        (0, vitest_1.it)('should validate voice synthesis example', () => {
            const result = orchestrator_1.AgentOutputZod.safeParse(orchestrator_1.VOICE_SYNTHESIS_EXAMPLE);
            (0, vitest_1.expect)(result.success).toBe(true);
        });
        (0, vitest_1.it)('should reject invalid agent output', () => {
            const invalidOutput = {
                enhancement_area: "", // Invalid: empty string
                objective: "Test objective",
                confidence_score: 1.5 // Invalid: > 1.0
            };
            const result = orchestrator_1.AgentOutputZod.safeParse(invalidOutput);
            (0, vitest_1.expect)(result.success).toBe(false);
            if (!result.success) {
                (0, vitest_1.expect)(result.error.issues.length).toBeGreaterThan(0);
            }
        });
        (0, vitest_1.it)('should validate enhancement area', () => {
            const validArea = {
                name: "Test Area",
                objective: "Test objective",
                key_requirements: ["req1", "req2"],
                sources: ["source1"],
                depends_on: ["dep1"]
            };
            const result = orchestrator_1.EnhancementAreaZod.safeParse(validArea);
            (0, vitest_1.expect)(result.success).toBe(true);
        });
        (0, vitest_1.it)('should validate security config', () => {
            const result = orchestrator_1.SecurityConfigZod.safeParse(orchestrator_1.DEFAULT_SECURITY_CONFIG);
            (0, vitest_1.expect)(result.success).toBe(true);
        });
    });
    (0, vitest_1.describe)('Manifest Compilation', () => {
        (0, vitest_1.it)('should compile manifest with basic enhancement areas', async () => {
            const enhancementAreas = [
                {
                    name: "Test Area 1",
                    objective: "Test objective 1",
                    key_requirements: ["req1"],
                    sources: ["source1"]
                },
                {
                    name: "Test Area 2",
                    objective: "Test objective 2",
                    key_requirements: ["req2"],
                    sources: ["source2"],
                    depends_on: ["Test Area 1"]
                }
            ];
            const manifest = await orchestrator_1.orchestrator.compileManifest(enhancementAreas, {
                validateAgainstPinecone: false,
                enableParallelProcessing: false,
                environment: 'development'
            });
            (0, vitest_1.expect)(manifest.enhancements).toHaveLength(2);
            (0, vitest_1.expect)(manifest.metadata).toBeDefined();
            (0, vitest_1.expect)(manifest.metadata.version).toBe('2.1.0');
            (0, vitest_1.expect)(manifest.metadata.environment).toBe('development');
            (0, vitest_1.expect)(manifest.roadmap).toBeDefined();
            (0, vitest_1.expect)(manifest.roadmap?.build_order).toBeDefined();
        });
        (0, vitest_1.it)('should handle parallel processing', async () => {
            const enhancementAreas = Array.from({ length: 5 }, (_, i) => ({
                name: `Test Area ${i + 1}`,
                objective: `Test objective ${i + 1}`,
                key_requirements: [`req${i + 1}`],
                sources: [`source${i + 1}`]
            }));
            const startTime = Date.now();
            const manifest = await orchestrator_1.orchestrator.compileManifest(enhancementAreas, {
                validateAgainstPinecone: false,
                enableParallelProcessing: true,
                environment: 'development'
            });
            const endTime = Date.now();
            (0, vitest_1.expect)(manifest.enhancements).toHaveLength(5);
            (0, vitest_1.expect)(endTime - startTime).toBeLessThan(5000); // Should complete quickly
        });
        (0, vitest_1.it)('should handle dependency cycles gracefully', async () => {
            const enhancementAreas = [
                {
                    name: "Area A",
                    objective: "Objective A",
                    key_requirements: ["req1"],
                    sources: ["source1"],
                    depends_on: ["Area B"]
                },
                {
                    name: "Area B",
                    objective: "Objective B",
                    key_requirements: ["req2"],
                    sources: ["source2"],
                    depends_on: ["Area A"]
                }
            ];
            await (0, vitest_1.expect)(orchestrator_1.orchestrator.compileManifest(enhancementAreas, {
                validateAgainstPinecone: false,
                enableParallelProcessing: false,
                environment: 'development'
            })).rejects.toThrow(orchestrator_1.OrchestratorError);
        });
    });
    (0, vitest_1.describe)('Agent Output Validation', () => {
        (0, vitest_1.it)('should validate multiple agent outputs', async () => {
            const outputs = [orchestrator_1.TREND_DETECTION_EXAMPLE, orchestrator_1.QUANTUM_OPTIMIZATION_EXAMPLE, orchestrator_1.VOICE_SYNTHESIS_EXAMPLE];
            const validation = await orchestrator_1.orchestrator.validateAgentOutputs(outputs);
            (0, vitest_1.expect)(validation.valid).toHaveLength(3);
            (0, vitest_1.expect)(validation.invalid).toHaveLength(0);
        });
        (0, vitest_1.it)('should identify invalid outputs', async () => {
            const outputs = [
                orchestrator_1.TREND_DETECTION_EXAMPLE,
                { invalid: 'data' }, // Invalid output
                orchestrator_1.VOICE_SYNTHESIS_EXAMPLE
            ];
            const validation = await orchestrator_1.orchestrator.validateAgentOutputs(outputs);
            (0, vitest_1.expect)(validation.valid).toHaveLength(2);
            (0, vitest_1.expect)(validation.invalid).toHaveLength(1);
            (0, vitest_1.expect)(validation.invalid[0].errors.length).toBeGreaterThan(0);
        });
    });
    (0, vitest_1.describe)('Delegation Execution', () => {
        (0, vitest_1.it)('should execute standard delegation', async () => {
            const results = await orchestrator_1.orchestrator.executeDelegation(orchestrator_1.TREND_DETECTION_EXAMPLE);
            (0, vitest_1.expect)(results.enhancement_area).toBe(orchestrator_1.TREND_DETECTION_EXAMPLE.enhancement_area);
            (0, vitest_1.expect)(results.execution_id).toBeDefined();
            (0, vitest_1.expect)(results.timestamp).toBeDefined();
            (0, vitest_1.expect)(results.results).toBeDefined();
            (0, vitest_1.expect)(results.results.implementation).toBeDefined();
        });
        (0, vitest_1.it)('should execute quantum delegation', async () => {
            const results = await orchestrator_1.orchestrator.executeDelegation(orchestrator_1.QUANTUM_OPTIMIZATION_EXAMPLE, {
                quantumBackend: 'simulator'
            });
            const quantumResults = results.results.quantum;
            (0, vitest_1.expect)(quantumResults).toBeDefined();
            (0, vitest_1.expect)(quantumResults?.backend).toBe('simulator');
        });
        (0, vitest_1.it)('should execute TTS delegation', async () => {
            const results = await orchestrator_1.orchestrator.executeDelegation(orchestrator_1.VOICE_SYNTHESIS_EXAMPLE, {
                voiceEngine: 'ECHO-GHOST'
            });
            const ttsResults = results.results.tts;
            (0, vitest_1.expect)(ttsResults).toBeDefined();
            (0, vitest_1.expect)(ttsResults?.engine).toBe('ECHO-GHOST');
            (0, vitest_1.expect)(ttsResults?.segments_processed ?? 0).toBeGreaterThan(0);
        });
        (0, vitest_1.it)('should handle delegation errors gracefully', async () => {
            const invalidOutput = {
                enhancement_area: "Invalid Test",
                // Missing required fields
            };
            await (0, vitest_1.expect)(orchestrator_1.orchestrator.executeDelegation(invalidOutput)).rejects.toThrow(orchestrator_1.OrchestratorError);
        });
    });
    (0, vitest_1.describe)('Error Handling', () => {
        (0, vitest_1.it)('should create OrchestratorError with proper structure', () => {
            const error = new orchestrator_1.OrchestratorError('Test error message', 'TEST_ERROR', ['Action 1', 'Action 2'], { context: 'test' });
            (0, vitest_1.expect)(error.message).toBe('Test error message');
            (0, vitest_1.expect)(error.errorType).toBe('TEST_ERROR');
            (0, vitest_1.expect)(error.recoveryActions).toEqual(['Action 1', 'Action 2']);
            (0, vitest_1.expect)(error.context).toEqual({ context: 'test' });
            (0, vitest_1.expect)(error.timestamp).toBeDefined();
            (0, vitest_1.expect)(error.correlationId).toBeDefined();
        });
        (0, vitest_1.it)('should serialize error to JSON', () => {
            const error = new orchestrator_1.OrchestratorError('Test error', 'TEST_ERROR', ['Action 1']);
            const json = error.toJSON();
            (0, vitest_1.expect)(json.name).toBe('OrchestratorError');
            (0, vitest_1.expect)(json.message).toBe('Test error');
            (0, vitest_1.expect)(json.errorType).toBe('TEST_ERROR');
            (0, vitest_1.expect)(json.recoveryActions).toEqual(['Action 1']);
            (0, vitest_1.expect)(json.timestamp).toBeDefined();
            (0, vitest_1.expect)(json.correlationId).toBeDefined();
        });
    });
    (0, vitest_1.describe)('Quantum Examples', () => {
        (0, vitest_1.it)('should provide valid QUBO example', () => {
            (0, vitest_1.expect)(orchestrator_1.DEFAULT_QUBO_EXAMPLE.type).toBe('QUBO');
            (0, vitest_1.expect)(orchestrator_1.DEFAULT_QUBO_EXAMPLE.parameters).toBeDefined();
            (0, vitest_1.expect)(orchestrator_1.DEFAULT_QUBO_EXAMPLE.parameters.variables).toBe(20);
        });
        (0, vitest_1.it)('should provide valid Grover oracle example', () => {
            (0, vitest_1.expect)(orchestrator_1.DEFAULT_GROVER_ORACLE_EXAMPLE.type).toBe('Oracle');
            (0, vitest_1.expect)(orchestrator_1.DEFAULT_GROVER_ORACLE_EXAMPLE.parameters).toBeDefined();
            (0, vitest_1.expect)(orchestrator_1.DEFAULT_GROVER_ORACLE_EXAMPLE.parameters.database_size).toBe(1000);
        });
    });
    (0, vitest_1.describe)('Security Configuration', () => {
        (0, vitest_1.it)('should return security config', () => {
            const config = orchestrator_1.orchestrator.getSecurityConfig();
            (0, vitest_1.expect)(config).toBeDefined();
            (0, vitest_1.expect)(config.rate_limiting.enabled).toBe(true);
        });
        (0, vitest_1.it)('should initialize with custom security config', () => {
            const customConfig = {
                ...orchestrator_1.DEFAULT_SECURITY_CONFIG,
                rate_limiting: {
                    ...orchestrator_1.DEFAULT_SECURITY_CONFIG.rate_limiting,
                    requests_per_minute: 200
                }
            };
            const customOrchestrator = new orchestrator_1.orchestrator.constructor(customConfig);
            const config = customOrchestrator.getSecurityConfig();
            (0, vitest_1.expect)(config.rate_limiting.requests_per_minute).toBe(200);
        });
    });
    (0, vitest_1.describe)('Service Initialization', () => {
        (0, vitest_1.it)('should initialize services without errors', async () => {
            await (0, vitest_1.expect)(orchestrator_1.orchestrator.initializeServices()).resolves.not.toThrow();
        });
        (0, vitest_1.it)('should track Pinecone initialization status', () => {
            const isInitialized = orchestrator_1.orchestrator.isPineconeInitialized();
            (0, vitest_1.expect)(typeof isInitialized).toBe('boolean');
        });
    });
});
(0, vitest_1.describe)('Integration Tests', () => {
    (0, vitest_1.it)('should handle complete workflow end-to-end', async () => {
        // 1. Compile manifest
        const enhancementAreas = [
            {
                name: "Integration Test Area",
                objective: "Test complete workflow",
                key_requirements: ["End-to-end testing"],
                sources: ["Test Source"]
            }
        ];
        const manifest = await orchestrator_1.orchestrator.compileManifest(enhancementAreas, {
            validateAgainstPinecone: false,
            enableParallelProcessing: true,
            environment: 'staging'
        });
        (0, vitest_1.expect)(manifest.enhancements).toHaveLength(1);
        // 2. Validate outputs
        const validation = await orchestrator_1.orchestrator.validateAgentOutputs(manifest.enhancements);
        (0, vitest_1.expect)(validation.valid).toHaveLength(1);
        (0, vitest_1.expect)(validation.invalid).toHaveLength(0);
        // 3. Execute delegation
        const results = await orchestrator_1.orchestrator.executeDelegation(manifest.enhancements[0]);
        (0, vitest_1.expect)(results.execution_id).toBeDefined();
        (0, vitest_1.expect)(results.results.implementation).toBeDefined();
        // 4. Check metadata
        (0, vitest_1.expect)(manifest.metadata.environment).toBe('staging');
        (0, vitest_1.expect)(manifest.metadata.total_enhancements).toBe(1);
    });
    (0, vitest_1.it)('should handle large batch processing', async () => {
        const enhancementAreas = Array.from({ length: 10 }, (_, i) => ({
            name: `Batch Test Area ${i + 1}`,
            objective: `Batch test objective ${i + 1}`,
            key_requirements: [`Batch req ${i + 1}`],
            sources: [`Batch source ${i + 1}`]
        }));
        const manifest = await orchestrator_1.orchestrator.compileManifest(enhancementAreas, {
            validateAgainstPinecone: false,
            enableParallelProcessing: true,
            environment: 'development'
        });
        (0, vitest_1.expect)(manifest.enhancements).toHaveLength(10);
        (0, vitest_1.expect)(manifest.metadata.total_enhancements).toBe(10);
    });
});
//# sourceMappingURL=orchestrator.test.js.map