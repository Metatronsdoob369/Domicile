"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AGENT_CODEX = void 0;
exports.buildManifestWithPinecone = buildManifestWithPinecone;
exports.buildDependencyGraph = buildDependencyGraph;
exports.buildManifest = buildManifest;
const data_1 = require("@domicile/data");
const domicile_agent_codex_1 = require("./domicile-agent-codex");
async function buildManifestWithPinecone(agents) {
    const accepted = [];
    for (const agent of agents) {
        const duplicateCheck = await validateAgainstExistingPinecone(agent);
        if (!duplicateCheck.isValid) {
            console.warn(`⚠️ Skipping ${agent.enhancement_area}: ${duplicateCheck.reason}`);
            continue;
        }
        accepted.push(agent);
        await (0, data_1.storeAgentInPinecone)(agent);
    }
    return {
        enhancements: accepted,
        roadmap: buildDependencyGraph(accepted),
    };
}
async function validateAgainstExistingPinecone(agent) {
    try {
        const results = await (0, data_1.searchPineconeRecords)(agent.objective || agent.enhancement_area);
        const duplicates = results.filter((match) => (match.score || 0) > 0.85);
        if (duplicates.length > 0) {
            return { isValid: false, reason: `Similar enhancement exists: ${duplicates[0].id}` };
        }
        const conflicts = results.filter((match) => Array.isArray(match.metadata?.depends_on) &&
            match.metadata.depends_on.includes(agent.enhancement_area));
        if (conflicts.length > 0) {
            return { isValid: false, reason: `Dependency conflict with ${conflicts[0].id}` };
        }
        return { isValid: true };
    }
    catch (error) {
        console.warn("⚠️ Pinecone validation failed, proceeding:", error);
        return { isValid: true };
    }
}
function buildDependencyGraph(agents) {
    const graph = new Map();
    const inDegree = new Map();
    for (const agent of agents) {
        graph.set(agent.enhancement_area, agent.depends_on || []);
        inDegree.set(agent.enhancement_area, 0);
    }
    for (const [node, deps] of graph) {
        for (const dep of deps) {
            if (graph.has(dep)) {
                inDegree.set(node, (inDegree.get(node) || 0) + 1);
            }
        }
    }
    const queue = Array.from(inDegree.entries())
        .filter(([, degree]) => degree === 0)
        .map(([name]) => name);
    const buildOrder = [];
    const edges = [];
    for (const [to, deps] of graph) {
        for (const from of deps) {
            if (graph.has(from)) {
                edges.push({ from, to });
            }
        }
    }
    while (queue.length) {
        const node = queue.shift();
        buildOrder.push(node);
        for (const [target, deps] of graph) {
            if (deps.includes(node)) {
                const newDegree = (inDegree.get(target) || 0) - 1;
                inDegree.set(target, newDegree);
                if (newDegree === 0) {
                    queue.push(target);
                }
            }
        }
    }
    if (buildOrder.length !== agents.length) {
        throw new Error(`Circular dependency detected. Offending nodes: ${agents
            .filter((agent) => !buildOrder.includes(agent.enhancement_area))
            .map((agent) => agent.enhancement_area)
            .join(", ")}`);
    }
    return {
        nodes: agents.map((agent) => agent.enhancement_area),
        edges,
        build_order: buildOrder,
    };
}
function buildManifest(agents) {
    return {
        enhancements: agents,
        roadmap: buildDependencyGraph(agents),
        capabilities: enrichCapabilities(agents),
    };
}
function enrichCapabilities(agents) {
    const capabilities = [];
    for (const agent of agents) {
        capabilities.push(...(0, domicile_agent_codex_1.inferCapabilitiesFromEnhancement)(agent));
    }
    return capabilities;
}
exports.AGENT_CODEX = domicile_agent_codex_1.DOMICILE_AGENT_CODEX;
//# sourceMappingURL=manifest-builder.js.map